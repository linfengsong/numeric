### Step-by-Step Proof

#### 1. **Necessity (⇒): If the congruences admit a simultaneous solution, then gcd(n, m) divides (a - b).**

Assume there exists an integer \( x \) such that:
\[
x \equiv a \pmod{n} \quad \text{and} \quad x \equiv b \pmod{m}.
\]
Then:
\[
x = a + nk, \quad x = b + m\ell \quad \text{for some integers } k, \ell.
\]
Subtracting:
\[
a + nk = b + m\ell \implies a - b = m\ell - nk.
\]
Let \( d = \gcd(n, m) \). Since \( d \) divides both \( n \) and \( m \), it divides \( m\ell - nk = a - b \). Hence:
\[
d \mid (a - b).
\]

#### 2. **Sufficiency (⇐): If gcd(n, m) divides (a - b), then a simultaneous solution exists.**

Let \( d = \gcd(n, m) \), and suppose \( d \mid (a - b) \). Write:
\[
n = d n', \quad m = d m', \quad \text{with } \gcd(n', m') = 1.
\]
We want to solve:
\[
x \equiv a \pmod{n}, \quad x \equiv b \pmod{m}.
\]
Since \( x \equiv a \pmod{n} \), we have \( x = a + nk \) for some integer \( k \). Substitute into the second congruence:
\[
a + nk \equiv b \pmod{m} \implies nk \equiv b - a \pmod{m}.
\]
Substitute \( n = d n' \), \( m = d m' \):
\[
d n' k \equiv b - a \pmod{d m'}.
\]
This implies \( d n' k - (b - a) \) is divisible by \( d m' \), so:
\[
d n' k \equiv b - a \pmod{d m'} \implies n' k \equiv \frac{b - a}{d} \pmod{m'}.
\]
Let \( c = \frac{b - a}{d} \) (which is an integer since \( d \mid (a - b) \)). Then:
\[
n' k \equiv -c \pmod{m'}.
\]
Since \( \gcd(n', m') = 1 \), \( n' \) has an inverse modulo \( m' \). Let \( k_0 \) be a solution to:
\[
k \equiv -c \cdot (n')^{-1} \pmod{m'}.
\]
Then \( k = k_0 + m' t \) for some integer \( t \). Then:
\[
x = a + nk = a + d n' (k_0 + m' t) = a + d n' k_0 + d n' m' t.
\]
So \( x \equiv a + d n' k_0 \pmod{d n' m'} \). But \( d n' m' = \text{lcm}(n, m) \), since:
\[
\text{lcm}(n, m) = \frac{n m}{\gcd(n, m)} = \frac{d n' \cdot d m'}{d} = d n' m'.
\]
Thus, a solution exists modulo \( \text{lcm}(n, m) \).

#### 3. **Uniqueness modulo lcm(n, m)**

Suppose \( x_1 \) and \( x_2 \) are two solutions. Then:
\[
x_1 \equiv x_2 \pmod{n}, \quad x_1 \equiv x_2 \pmod{m}.
\]
So \( n \mid (x_1 - x_2) \) and \( m \mid (x_1 - x_2) \). Therefore, \( \text{lcm}(n, m) \mid (x_1 - x_2) \), i.e.,
\[
x_1 \equiv x_2 \pmod{\text{lcm}(n, m)}.
\]
Hence, the solution is unique modulo \( \text{lcm}(n, m) \).

### ✅ Final Conclusion:
The congruences \( x \equiv a \pmod{n} \) and \( x \equiv b \pmod{m} \) have a simultaneous solution **if and only if** \( \gcd(n, m) \mid (a - b) \). Moreover, if a solution exists, it is **unique modulo** \( \text{lcm}(n, m) \).

---

### Lean 4 Statement (for verification)
```lean
import Mathlib.Algebra.Module.Basic
import Mathlib.Data.Int.GCD
import Mathlib.Data.Int.ModEq
import Mathlib.Tactic

theorem chinese_remainder_theorem (a b : ℤ) (n m : ℕ) (hn : n > 0) (hm : m > 0) :
    (∃ x : ℤ, [x ≡ a [ZMOD n] ∧ x ≡ b [ZMOD m]]) ↔ ↑(Int.gcd n m) ∣ (a - b) := by
  constructor
  · intro ⟨x, h1, h2⟩
    have h : ↑(Int.gcd n m) ∣ (a - b) := by
      obtain ⟨k, hk⟩ := h1
      obtain ⟨l, hl⟩ := h2
      have : a - b = m * l - n * k := by linarith [hk, hl]
      rw [this]
      exact Int.dvd_sub_of_dvd_add (Int.gcd_dvd_gcd_mul_right n m) (Int.gcd_dvd_gcd_mul_left m n)
    exact h
  · intro h
    let d := Int.gcd n m
    have hd : d = Int.gcd n m := rfl
    have : d ∣ (a - b) := h
    -- Construct solution using Bézout's identity and show existence
    obtain ⟨x, y, hxy⟩ : ∃ x y, n * x + m * y = d := Int.gcd_eq_gcd_ab n m
    have : d ∣ a - b := h
    obtain ⟨c, hc⟩ := this
    use a + n * x * c
    constructor
    · apply Int.ModEq.of_int
      simp [Int.add_mul_mod_right]
    · rw [← Int.modEq_iff_dvd, ← hc]
      calc
        a + n * x * c ≡ a + n * x * c := by rfl
        _ = a + (d - m * y) * c := by rw [← hxy]
        _ = a + d * c - m * (y * c) := by ring
        _ ≡ a + d * c [ZMOD m] := by apply Int.ModEq.sub_right _ (Int.modEq_of_dvd (by exact ⟨y * c, by ring⟩))
        _ ≡ a + (a - b) [ZMOD m] := by rw [hc]
        _ = 2 * a - b := by ring
        _ ≡ b [ZMOD m] ?_  -- Need to show 2a - b ≡ b mod m, i.e., 2(a - b) ≡ 0 mod m, which holds since d∣a-b and m∣m, but d = gcd(n,m) and m/d is integer.
        -- This part requires more careful handling; typically we use the fact that m ∣ d * (something)
        -- Actually, a better approach is to use the standard method as in the proof above.
        -- Due to complexity, we might instead rely on `Mathlib`'s existing Chinese Remainder Theorem.
      skip  -- In practice, use `Mathlib.NumberTheory.Zsqrtd.Basic` or similar for a full proof.
```

**Note:** The Lean proof above is a sketch. For a complete formalization, it is recommended to use Mathlib's built-in Chinese Remainder Theorem, e.g., `Int.chineseRemainderTheorem` from `Mathlib.Data.Int.ModEq`. The necessity direction is straightforward, but sufficiency is more involved. The uniqueness modulo `lcm(n, m)` can be stated as:

```lean
theorem chinese_remainder_unique (a b : ℤ) (n m : ℕ) (hn : n > 0) (hm : m > 0) (x y : ℤ)
    (hx : [x ≡ a [ZMOD n] ∧ x ≡ b [ZMOD m]]) (hy : [y ≡ a [ZMOD n] ∧ y ≡ b [ZMOD m]]) :
    [x ≡ y [ZMOD (Nat.lcm n m)]] := by
  rcases hx with ⟨hx1, hx2⟩
  rcases hy with ⟨hy1, hy2⟩
  apply Int.modEq_of_dvd
  exact Nat.lcm_dvd (Int.dvd_of_modEq hx1 hy1) (Int.dvd_of_modEq hx2 hy2)
```

For a full Lean proof, consider using:
```lean
import Mathlib.NumberTheory.Zsqrtd.Basic
```

The existence and uniqueness are encapsulated in:
```lean
Int.chineseRemainderTheorem : ∀ {m n : ℤ} (h : m.gcd n = 1) (a b : ℤ), ∃ x, [x ≡ a [ZMOD m] ∧ x ≡ b [ZMOD n]]
```

But to relate to `lcm`, further steps are needed. The above sketch provides the structure.