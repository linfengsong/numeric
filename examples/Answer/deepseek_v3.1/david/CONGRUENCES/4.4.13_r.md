### Step 1: Understand the Given

We are given:
- \( x \equiv a \pmod{n} \)
- This means \( n \mid (x - a) \), so \( x - a = kn \) for some integer \( k \).

We want to prove:
- Either \( x \equiv a \pmod{2n} \) or \( x \equiv a + n \pmod{2n} \).

---

### Step 2: Express \( x \) in Terms of \( a \) and \( n \)

Since \( x \equiv a \pmod{n} \), we have:
\[
x = a + kn \quad \text{for some integer } k.
\]

Now, consider modulo \( 2n \). We want to see what \( x \) is modulo \( 2n \).

---

### Step 3: Consider the Parity of \( k \)

Write \( k \) as either even or odd:
- If \( k \) is even, say \( k = 2m \), then:
  \[
  x = a + (2m)n = a + 2mn \implies x \equiv a \pmod{2n}.
  \]
- If \( k \) is odd, say \( k = 2m + 1 \), then:
  \[
  x = a + (2m + 1)n = a + 2mn + n = (a + n) + 2mn \implies x \equiv a + n \pmod{2n}.
  \]

---

### Step 4: Conclusion

Since every integer \( k \) is either even or odd, we have covered all cases:
- If \( k \) is even, \( x \equiv a \pmod{2n} \).
- If \( k \) is odd, \( x \equiv a + n \pmod{2n} \).

Therefore, one of the two congruences must hold.

---

### ✅ Final Proof

**Given:** \( x \equiv a \pmod{n} \), so \( x = a + kn \) for some integer \( k \).

**Case 1:** \( k \) is even, i.e., \( k = 2m \) for some integer \( m \). Then:
\[
x = a + (2m)n = a + 2mn \implies x \equiv a \pmod{2n}.
\]

**Case 2:** \( k \) is odd, i.e., \( k = 2m + 1 \) for some integer \( m \). Then:
\[
x = a + (2m + 1)n = a + 2mn + n = (a + n) + 2mn \implies x \equiv a + n \pmod{2n}.
\]

Since every integer \( k \) is either even or odd, we conclude that either \( x \equiv a \pmod{2n} \) or \( x \equiv a + n \pmod{2n} \). ∎

---

### Lean 4 Statement

```lean
theorem mod_cases (x a n : ℤ) (h : x ≡ a [ZMOD n]) :
    (x ≡ a [ZMOD 2 * n]) ∨ (x ≡ a + n [ZMOD 2 * n]) := by
  rcases h with ⟨k, hk⟩
  have : x = a + k * n := by linarith [hk]
  by_cases hk_even : Even k
  · left
    rcases hk_even with ⟨m, hm⟩
    have : x = a + 2 * m * n := by
      rw [hm] at this
      ring_nf at this ⊢
      exact this
    intro t
    rw [this]
    exact ⟨m, by ring⟩
  · right
    have : Odd k := by
      rw [Odd]
      refine ⟨k / 2, ?_⟩
      have : k = 2 * (k / 2) + k % 2 := by exact Int.ediv_add_emod k 2
      have mod_eq_one : k % 2 = 1 := by
        have := Int.mod_two_eq_zero_or_one k
        rcases this with (h | h)
        · exfalso
          apply hk_even
          exact ⟨k/2, by rw [← h, Int.add_zero] at this; linarith⟩
        · exact h
      linarith
    rcases this with ⟨m, hm⟩
    have : x = a + n + 2 * m * n := by
      rw [hm] at this
      ring_nf at this ⊢
      exact this
    intro t
    rw [this]
    exact ⟨m, by ring⟩
```

**Note:** The Lean proof above uses definitions for `Even` and `Odd` (which are standard in mathlib). Alternatively, one can avoid these by using `k % 2` directly, but the above is a natural translation.

---

### Output in Normal Language

If \( x \) is congruent to \( a \) modulo \( n \), then \( x = a + kn \) for some integer \( k \).  
- If \( k \) is even (\( k = 2m \)), then \( x = a + 2mn \), so \( x \equiv a \pmod{2n} \).  
- If \( k \) is odd (\( k = 2m + 1 \)), then \( x = a + (2m + 1)n = a + n + 2mn \), so \( x \equiv a + n \pmod{2n} \).  

Since every integer \( k \) is either even or odd, the result follows.