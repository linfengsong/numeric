### (a) Generalization of Theorem 4.6

**Theorem:**  
If an integer \( N \) is represented in base \( b \) as  
\[
N = a_m b^m + a_{m-1} b^{m-1} + \ldots + a_1 b + a_0, \quad \text{where } 0 \leq a_k \leq b-1,
\]  
then \( b-1 \mid N \) if and only if \( b-1 \mid (a_m + a_{m-1} + \ldots + a_1 + a_0) \).

**Proof Sketch:**  
Note that \( b \equiv 1 \pmod{b-1} \), so \( b^k \equiv 1 \pmod{b-1} \) for all \( k \geq 0 \). Therefore,  
\[
N = a_m b^m + \ldots + a_1 b + a_0 \equiv a_m + a_{m-1} + \ldots + a_1 + a_0 \pmod{b-1}.
\]  
Thus, \( N \equiv S \pmod{b-1} \), where \( S \) is the sum of digits. Hence, \( b-1 \mid N \) if and only if \( b-1 \mid S \).

---

### (b) Divisibility Criteria in Base 9

Given \( N \) written in base 9:  
\[
N = (a_m a_{m-1} \ldots a_1 a_0)_9.
\]

- **Divisibility by 3:**  
  Since \( 9 \equiv 0 \pmod{3} \), we have \( 9^k \equiv 0 \pmod{3} \) for \( k \geq 1 \). Thus,  
  \[
  N = a_m \cdot 9^m + \ldots + a_1 \cdot 9 + a_0 \equiv a_0 \pmod{3}.
  \]  
  Therefore, \( 3 \mid N \) if and only if \( 3 \mid a_0 \) (i.e., the last digit \( a_0 \) is divisible by 3).

- **Divisibility by 8:**  
  Note that \( 9 \equiv 1 \pmod{8} \), so \( 9^k \equiv 1 \pmod{8} \) for all \( k \geq 0 \). Then,  
  \[
  N = a_m \cdot 9^m + \ldots + a_1 \cdot 9 + a_0 \equiv a_m + a_{m-1} + \ldots + a_1 + a_0 \pmod{8}.
  \]  
  Therefore, \( 8 \mid N \) if and only if \( 8 \mid (a_m + a_{m-1} + \ldots + a_1 + a_0) \).

---

### (c) Check Divisibility of \( (447836)_9 \) by 3 and 8

First, write the number in base 9:  
\[
N = (4\,4\,7\,8\,3\,6)_9.
\]

- **Check divisibility by 3:**  
  The last digit is \( 6 \). Since \( 3 \mid 6 \), we conclude \( 3 \mid N \).

- **Check divisibility by 8:**  
  Compute the sum of digits:  
  \[
  S = 4 + 4 + 7 + 8 + 3 + 6 = 32.
  \]  
  Since \( 8 \mid 32 \), we conclude \( 8 \mid N \).

**Final Answer:**  
Yes, \( (447836)_9 \) is divisible by both 3 and 8.

---

### Lean 4 Statement (for part (a))

```lean
theorem base_b_divisibility (b : ℕ) (h : 1 < b) (N : ℕ) :
    (b - 1) ∣ N ↔ (b - 1) ∣ (Nat.digits b N).sum := by
  have h1 : b - 1 ≠ 0 := by omega
  rw [← Nat.modEq_zero] at h1
  have h2 : b ≡ 1 [MOD b - 1] := by
    have : b - 1 ∣ b - 1 := by exact dvd_refl (b - 1)
    exact Nat.modEq_of_dvd (by omega)
  have h3 : ∀ k, b ^ k ≡ 1 [MOD b - 1] := by
    intro k
    induction' k with k IH
    · rfl
    · rw [pow_succ]
      exact (h2.mul IH)
  have : N ≡ (Nat.digits b N).sum [MOD b - 1] := by
    rw [Nat.ofDigits_digits b N]
    refine Nat.ModEq.add_left _ (Nat.ModEq.add_left _ (Nat.ModEq.add_left _ ?_))
    -- Alternatively, use induction on digits
    sorry  -- Full proof requires more details, but the idea is as above.
  constructor
  · intro hN
    exact Nat.modEq_zero_iff_dvd.mp (this.symm.trans (Nat.modEq_zero_iff_dvd.mpr hN))
  · intro hS
    exact Nat.modEq_zero_iff_dvd.mp (this.trans (Nat.modEq_zero_iff_dvd.mpr hS))
```

*Note: The Lean proof is sketched; a complete proof would require more details, such as induction on the digits.*