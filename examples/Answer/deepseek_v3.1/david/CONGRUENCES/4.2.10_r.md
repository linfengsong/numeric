I'll prove this step by step and then formalize it in Lean.

### Proof:

Let $a_1, a_2, ..., a_n$ be a complete set of residues modulo $n$, meaning they represent all congruence classes modulo $n$ exactly once. Since gcd($a$, $n$) = 1, $a$ has a multiplicative inverse modulo $n$.

We need to show that $aa_1, aa_2, ..., aa_n$ is also a complete set of residues modulo $n$.

1. **Distinctness**: Suppose $aa_i ≡ aa_j \pmod{n}$ for some $i ≠ j$. Since gcd($a$, $n$) = 1, we can multiply both sides by $a^{-1}$ modulo $n$ to get $a_i ≡ a_j \pmod{n}$. But this contradicts the assumption that $a_1, ..., a_n$ is a complete set of residues (all distinct modulo $n$). Therefore, all $aa_i$ are distinct modulo $n$.

2. **Completeness**: There are exactly $n$ numbers $aa_1, ..., aa_n$, all distinct modulo $n$, so they must represent all $n$ residue classes modulo $n$.

Thus, $aa_1, aa_2, ..., aa_n$ is also a complete set of residues modulo $n$.

### Lean Formalization:

```lean
import Mathlib.Algebra.Module.Basic
import Mathlib.Tactic

theorem complete_residue_set_mult (n : ℕ) (hn : n > 0) (a : ℤ) (ha : Nat.Coprime a.natAbs n) 
    (s : Finset ℤ) (hs : s.card = n) (hcomp : ∀ x : ℤ, ∃! y ∈ s, x ≡ y [ZMOD n]) :
    let s' : Finset ℤ := Finset.image (λ x => a * x) s
    in s'.card = n ∧ ∀ x : ℤ, ∃! y ∈ s', x ≡ y [ZMOD n] := by
  intro s'
  have hcoprime : (a : ℤ).natAbs.Coprime n := ha
  have hinv : ∃ (b : ℤ), a * b ≡ 1 [ZMOD n] := by
    rw [Int.modEq_comm, ← Int.exists_mul_emod_eq_one_of_coprime]
    exact ha
  
  constructor
  · -- Show s' has cardinality n
    rw [Finset.card_image_of_injective]
    · exact hs
    · intro x y hxy
      rcases hinv with ⟨b, hb⟩
      have : a * x = a * y → x = y := by
        intro h
        have : b * (a * x) = b * (a * y) := by rw [h]
        simp_rw [← mul_assoc] at this
        rw [hb] at this
        simp at this
        exact this
      exact this hxy
  
  · -- Show s' is complete
    intro x
    rcases hcomp (x * (Classical.choose hinv)) with ⟨y, hy, huniq⟩
    refine ⟨a * y, by
      simp [s', hy], ?_, ?_⟩
    · -- x ≡ a*y mod n
      rcases hy with ⟨y_mem, _⟩
      have : x * (Classical.choose hinv) ≡ y [ZMOD n] := huniq.1
      calc x ≡ x * 1 : by ring
           _ ≡ x * (a * Classical.choose hinv) : by rw [Classical.choose_spec hinv]
           _ ≡ a * (x * Classical.choose hinv) : by ring
           _ ≡ a * y : by rw [this]
    
    · -- Uniqueness
      intro z hz
      rcases Finset.mem_image.mp hz with ⟨w, hw, hzw⟩
      rw [← hzw]
      intro h
      have : x ≡ a * w [ZMOD n] := h
      have : x * Classical.choose hinv ≡ a * w * Classical.choose hinv [ZMOD n] := by
        rw [this]
      simp_rw [mul_assoc] at this
      rw [Classical.choose_spec hinv] at this
      simp at this
      have := huniq.2 w (by exact hw) this
      rw [this]
```

### Normal Language Output:

The proof shows that multiplying a complete set of residues modulo n by an integer a that is coprime with n produces another complete set of residues modulo n. This works because:

1. The multiplication preserves distinctness: if two different residues give the same result when multiplied by a, this would imply the original residues were congruent modulo n, contradicting the completeness assumption.

2. The multiplication covers all residues: since a has a multiplicative inverse modulo n (due to the coprimality condition), we can recover any residue class by multiplying the appropriate element from the new set by this inverse.

This result is fundamental in number theory and has applications in various areas including cryptography and coding theory.