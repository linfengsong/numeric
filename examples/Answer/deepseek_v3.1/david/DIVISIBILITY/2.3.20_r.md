### Proofs in Lean

Here are the proofs of the given properties using Lean:

```lean
import Mathlib.Data.Int.GCD

-- (a) If gcd(a, b) = 1, and gcd(a, c) = 1, then gcd(a, bc)= 1.
theorem part_a (a b c : ℤ) (h1 : Int.gcd a b = 1) (h2 : Int.gcd a c = 1) : Int.gcd a (b * c) = 1 := by
  rw [Int.gcd_eq_one_iff_coprime] at *
  exact (h1.mul_right h2)

-- (b) If gcd(a, b) = 1, and c | a, then gcd(b, c) = 1.
theorem part_b (a b c : ℤ) (h1 : Int.gcd a b = 1) (h2 : c ∣ a) : Int.gcd b c = 1 := by
  rw [Int.gcd_eq_one_iff_coprime] at *
  exact h1.symm.dvd_of_dvd_mul_left (dvd_mul_of_dvd_right h2 b)

-- (c) If gcd(a, b) = 1, then gcd(ac, b) = gcd(c, b).
theorem part_c (a b c : ℤ) (h : Int.gcd a b = 1) : Int.gcd (a * c) b = Int.gcd c b := by
  rw [Int.gcd_eq_one_iff_coprime] at h
  rw [Int.gcd_eq_gcd_ab, Int.gcd_eq_gcd_ab]
  simp [h, add_mul, mul_add]

-- (d) If gcd(a, b) = 1, and c | a + b, then gcd(a, c) = gcd(b, c) = 1.
theorem part_d (a b c : ℤ) (h1 : Int.gcd a b = 1) (h2 : c ∣ a + b) : Int.gcd a c = 1 ∧ Int.gcd b c = 1 := by
  constructor
  · rw [Int.gcd_eq_one_iff_coprime]
    intro p hp hpc
    have := h1.symm.dvd_of_dvd_mul_left (dvd_add (hp.mul_right _) (hp.mul_right _))
    exact this (dvd_add (dvd_mul_left p a) (dvd_mul_left p b))
  · rw [Int.gcd_eq_one_iff_coprime]
    intro p hp hpc
    have := h1.symm.dvd_of_dvd_mul_left (dvd_add (hp.mul_right _) (hp.mul_right _))
    exact this (dvd_add (dvd_mul_left p a) (dvd_mul_left p b))

-- (e) If gcd(a, b) = 1, d | ac, and d | bc, then d | c.
theorem part_e (a b c d : ℤ) (h : Int.gcd a b = 1) (h1 : d ∣ a * c) (h2 : d ∣ b * c) : d ∣ c := by
  rw [Int.gcd_eq_one_iff_coprime] at h
  exact h.dvd_of_dvd_mul h1 h2

-- (f) If gcd(a, b) = 1, then gcd(a², b²) = 1.
theorem part_f (a b : ℤ) (h : Int.gcd a b = 1) : Int.gcd (a ^ 2) (b ^ 2) = 1 := by
  rw [Int.gcd_eq_one_iff_coprime] at *
  exact h.pow 2
```

### Explanation in Normal Language

**(a)** If \(a\) is coprime with \(b\) and with \(c\), then \(a\) is coprime with \(b \times c\).  
This is because any prime dividing \(a\) and \(bc\) would have to divide either \(b\) or \(c\), contradicting the coprimality conditions.

**(b)** If \(a\) and \(b\) are coprime, and \(c\) divides \(a\), then \(b\) and \(c\) are coprime.  
Any common divisor of \(b\) and \(c\) would also divide \(a\) (since \(c \mid a\)), hence would divide \(\gcd(a,b) = 1\).

**(c)** If \(a\) and \(b\) are coprime, then \(\gcd(ac, b) = \gcd(c, b)\).  
This follows from the fact that since \(a\) and \(b\) share no common factors, the factors of \(b\) in \(ac\) come only from \(c\).

**(d)** If \(a\) and \(b\) are coprime, and \(c\) divides \(a + b\), then \(a\) and \(c\) are coprime, and \(b\) and \(c\) are coprime.  
If a prime \(p\) divided both \(a\) and \(c\), it would divide \(a + b\) (since \(c \mid a + b\)) and hence \(b\), contradicting \(\gcd(a,b) = 1\). Similarly for \(b\) and \(c\).

**(e)** If \(a\) and \(b\) are coprime, and \(d\) divides both \(ac\) and \(bc\), then \(d\) divides \(c\).  
This is a consequence of the generalization of Euclid's lemma: since \(a\) and \(b\) are coprime, any divisor of both \(ac\) and \(bc\) must divide \(c\).

**(f)** If \(a\) and \(b\) are coprime, then \(a^2\) and \(b^2\) are coprime.  
Squaring does not introduce any new common factors; if \(a\) and \(b\) share no primes, then \(a^2\) and \(b^2\) also share no primes.

These properties highlight how the gcd operation behaves under multiplication and addition when numbers are coprime, and they are fundamental in number theory.