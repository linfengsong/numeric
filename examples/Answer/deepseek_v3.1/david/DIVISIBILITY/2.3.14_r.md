I'll prove each part using the Euclidean algorithm and properties of gcd.

### (a) gcd(2a + 1, 9a + 4) = 1

Let's use the Euclidean algorithm:
```
gcd(9a + 4, 2a + 1)
= gcd((9a + 4) - 4(2a + 1), 2a + 1)
= gcd(9a + 4 - 8a - 4, 2a + 1)
= gcd(a, 2a + 1)
= gcd(a, (2a + 1) - 2a)
= gcd(a, 1)
= 1
```

### (b) gcd(5a + 2, 7a + 3) = 1

Using the Euclidean algorithm:
```
gcd(7a + 3, 5a + 2)
= gcd((7a + 3) - (5a + 2), 5a + 2)
= gcd(2a + 1, 5a + 2)
= gcd(2a + 1, (5a + 2) - 2(2a + 1))
= gcd(2a + 1, 5a + 2 - 4a - 2)
= gcd(2a + 1, a)
= gcd(a, (2a + 1) - 2a)
= gcd(a, 1)
= 1
```

### (c) If a is odd, then gcd(3a, 3a + 2) = 1

Let d = gcd(3a, 3a + 2). Then:
d divides both 3a and 3a + 2, so d divides their difference:
d divides (3a + 2) - 3a = 2

Therefore d divides 2, so d ∈ {1, 2}

Since a is odd, 3a is odd (odd × odd = odd), so gcd(3a, 3a + 2) cannot be 2 (since 2 would divide an odd number). Therefore d = 1.

### Lean Statements

```lean
theorem part_a (a : ℤ) : Nat.gcd (2*a + 1) (9*a + 4) = 1 := by
  have h : (9*a + 4) - 4*(2*a + 1) = a := by ring
  calc
    Nat.gcd (2*a + 1) (9*a + 4) = Nat.gcd (2*a + 1) a := by
      rw [Nat.gcd_eq_right (show a ∣ 9*a + 4 - 4*(2*a + 1) from by rw [h])]
    _ = Nat.gcd a (2*a + 1) := Nat.gcd_comm _ _
    _ = Nat.gcd a 1 := by
      rw [Nat.gcd_eq_right (show 1 ∣ 2*a + 1 - 2*a from by ring_nf)]
    _ = 1 := Nat.gcd_one_right _

theorem part_b (a : ℤ) : Nat.gcd (5*a + 2) (7*a + 3) = 1 := by
  have h1 : (7*a + 3) - (5*a + 2) = 2*a + 1 := by ring
  have h2 : (5*a + 2) - 2*(2*a + 1) = a := by ring
  have h3 : (2*a + 1) - 2*a = 1 := by ring
  calc
    Nat.gcd (5*a + 2) (7*a + 3) = Nat.gcd (5*a + 2) (2*a + 1) := by
      rw [Nat.gcd_eq_right (show 2*a + 1 ∣ 7*a + 3 - (5*a + 2) from by rw [h1])]
    _ = Nat.gcd (2*a + 1) (5*a + 2) := Nat.gcd_comm _ _
    _ = Nat.gcd (2*a + 1) a := by
      rw [Nat.gcd_eq_right (show a ∣ 5*a + 2 - 2*(2*a + 1) from by rw [h2])]
    _ = Nat.gcd a (2*a + 1) := Nat.gcd_comm _ _
    _ = Nat.gcd a 1 := by
      rw [Nat.gcd_eq_right (show 1 ∣ 2*a + 1 - 2*a from by rw [h3])]
    _ = 1 := Nat.gcd_one_right _

theorem part_c (a : ℤ) (h : a % 2 = 1) : Nat.gcd (3*a) (3*a + 2) = 1 := by
  have d_divides_2 : ∀ d, d ∣ Nat.gcd (3*a) (3*a + 2) → d ∣ 2 := by
    intro d hd
    have : (d : ℤ) ∣ (3*a + 2 : ℤ) - (3*a : ℤ) :=
      Int.dvd_sub_of_dvd_add (Int.coe_nat_dvd.mpr hd)
    simp at this
    exact this
  have gcd_divides_2 : Nat.gcd (3*a) (3*a + 2) ∣ 2 :=
    Nat.dvd_of_dvd_of_eq (d_divides_2 _ (dvd_refl _)) rfl
  have three_a_odd : (3*a : ℤ) % 2 = 1 := by
    rw [show (3 : ℤ) % 2 = 1 by norm_num, show (a : ℤ) % 2 = 1 from h]
    norm_num
  rcases gcd_divides_2 with (hgcd | hgcd)
  · exact hgcd
  · exfalso
    have : 2 ∣ (3*a : ℕ) := Nat.dvd_trans (by rw [hgcd]) (Nat.gcd_dvd_left _ _)
    have : (2 : ℤ) ∣ (3*a : ℤ) := Int.coe_nat_dvd.mpr this
    have := Int.emod_add_div (3*a) 2 ▸ this
    linarith [three_a_odd]
```

### Summary

All three statements are true:
1. gcd(2a + 1, 9a + 4) = 1 for any integer a
2. gcd(5a + 2, 7a + 3) = 1 for any integer a  
3. gcd(3a, 3a + 2) = 1 when a is odd

The proofs use the Euclidean algorithm and the property that if d divides both numbers, then d divides their difference. The Lean code provides formal verification of these results.