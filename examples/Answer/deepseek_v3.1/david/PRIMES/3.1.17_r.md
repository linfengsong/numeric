Let's verify the statement: "Any integer \( n \) can be expressed as \( n = 2^k m \), where \( k \geq 0 \) and \( m \) is an odd integer."

**Proof:**
Consider an integer \( n \). There are two cases:

1. If \( n = 0 \):
   - We can write \( 0 = 2^k \cdot 0 \) for any \( k \geq 0 \). However, note that \( m = 0 \) is not odd. But the statement says "m is an odd integer". So we need to be careful.
   - Actually, the statement is typically considered for nonzero integers. For \( n = 0 \), we might define \( k = 0 \) and \( m = 0 \), but 0 is even (not odd). So the statement is usually meant for nonzero integers. Alternatively, we can allow \( m=0 \) as a special case? But the problem says "m is an odd integer", which excludes 0.
   - Therefore, it's better to note that the statement holds for all nonzero integers. For \( n=0 \), it doesn't fit perfectly. However, in many contexts, we consider \( n=0 \) separately.

2. For nonzero \( n \):
   - Let \( k \) be the highest power of 2 that divides \( n \). That is, \( 2^k \) divides \( n \), but \( 2^{k+1} \) does not.
   - Then write \( n = 2^k \cdot m \).
   - Now, \( m = n / 2^k \). Since \( 2^k \) is the highest power dividing \( n \), \( m \) is an integer and is not divisible by 2 (because if it were, then \( 2^{k+1} \) would divide \( n \), contradicting the maximality of \( k \)). Therefore, \( m \) is odd.

So for every nonzero integer \( n \), we can write \( n = 2^k m \) with \( k \geq 0 \) and \( m \) odd.

For \( n=0 \), we can define \( k=0 \) and \( m=0 \), but 0 is not odd. So we might say the statement is true for all integers if we allow \( m=0 \) (which is even) as an exception. Alternatively, we can state that the representation holds for all nonzero integers.

In practice, this representation is standard and is called the "2-adic valuation" or the "decomposition into an odd part and a power of 2".

**Lean Statement:**
We can formalize this in Lean. Note that Lean has built-in notions of even/odd and divisibility.

```lean
theorem exists_odd_and_power_of_two (n : ℤ) : ∃ (k : ℕ) (m : ℤ), n = (2 : ℤ)^k * m ∧ odd m := by
  refine match n with
  | 0 => ⟨0, 0, by simp, by unfold odd; simp⟩
  | _ => ?_
  -- For nonzero n, we need to find k and m.
  -- Actually, for n=0, we set k=0, m=0, but 0 is not odd. So we should avoid n=0?
  -- Alternatively, we can define odd(0) as false? But Lean's `odd` is defined as `∃ k, n = 2*k+1`, which is false for 0.
  -- So we should handle n=0 separately? Or the theorem is only for nonzero n?
  -- Let's restrict to nonzero n.

  -- Actually, the statement is true for all n if we allow m=0? But then m=0 is not odd.
  -- So we can do:
  by_cases h : n = 0
  · subst h
    refine ⟨0, 0, by simp, ?_⟩
    unfold odd
    simp
  · -- n ≠ 0
    let k := (n.abs).factorization 2 -- This is the multiplicity of 2 in n
    have hk : 2^k ∣ n := ...
    ...
```

But actually, it's easier to use the existence of the maximal k such that 2^k divides n. We can use `multiplicity`:

```lean
import Mathlib.NumberTheory.Padics.PadicVal
import Mathlib.Data.Int.Basic

open multiplicity

theorem exists_odd_and_power_of_two (n : ℤ) : ∃ (k : ℕ) (m : ℤ), n = (2 : ℤ)^k * m ∧ odd m := by
  by_cases h : n = 0
  · subst h
    refine ⟨0, 0, by simp, ⟨0, by decide⟩⟩  -- But 0 is not odd? Actually `odd 0` is false.
    -- So we have a problem for n=0.
    -- Alternatively, we can exclude n=0.
  · have := finite_int_iff.2 ⟨by simp, h⟩
    let k := (multiplicity 2 n).get this
    have h2k : (2 : ℤ)^k ∣ n := ...
    ...
```

This might be a bit advanced. Alternatively, we can use:

```lean
theorem exists_odd_and_power_of_two (n : ℤ) (hn : n ≠ 0) : ∃ (k : ℕ) (m : ℤ), n = (2 : ℤ)^k * m ∧ odd m := by
  let k := padicValNat 2 (Int.natAbs n)
  have h : (2 : ℤ)^k ∣ n := ...
  ...
```

Given the complexity, it's better to use the library function `padicValInt`.

Actually, we can do:

```lean
import Mathlib.NumberTheory.Padics.PadicVal

open Int

theorem exists_odd_and_power_of_two (n : ℤ) : ∃ (k : ℕ) (m : ℤ), n = (2 : ℤ)^k * m ∧ odd m := by
  by_cases h : n = 0
  · subst h
    refine ⟨0, 0, by simp, ?_⟩
    rw [odd_iff_not_even]
    simp
  · set k := padicValInt 2 n with hk_def
    have hk : (2 : ℤ)^k ∣ n := padicValInt_dvd
    obtain ⟨m, rfl⟩ := hk
    have hm : odd m := by
      contrapose! h
      have := padicValInt_lt 2 h
      ...
    exact ⟨k, m, rfl, hm⟩
```

But to avoid going too deep, we can state the theorem for nonzero n.

Alternatively, we can prove it without libraries by well-founded recursion.

Given the time, I'll provide a simpler Lean statement for nonzero n:

```lean
theorem exists_odd_and_power_of_two (n : ℤ) (hn : n ≠ 0) : ∃ (k : ℕ) (m : ℤ), n = (2 : ℤ)^k * m ∧ odd m := by
  -- Proof sketch: repeatedly divide by 2 until odd.
  ...
```

**Output in normal language:**
The statement is true for all nonzero integers \( n \). Specifically, for any nonzero integer \( n \), let \( k \) be the largest nonnegative integer such that \( 2^k \) divides \( n \). Then \( n = 2^k \cdot m \), and \( m \) is an odd integer. For \( n = 0 \), we can write \( 0 = 2^0 \cdot 0 \), but 0 is not odd. Therefore, the statement holds for all integers if we allow \( m = 0 \) (which is even) as a special case, or we can restrict the statement to nonzero integers.

In practice, this decomposition is unique and is often used in number theory.