### Lean4 Proof

```lean4
theorem lcm_gcd_iff (a b : ℤ) (ha : a ≠ 0) (hb : b ≠ 0) : gcd a b = lcm a b ↔ a = b ∨ a = -b := by
  have h₁ : gcd a b = lcm a b ↔ a = b ∨ a = -b := by
    constructor
    · intro h
      have h₂ : gcd a b * lcm a b = a * b := by apply Int.gcd_mul_lcm
      rw [h] at h₂
      have h₃ : (gcd a b) ^ 2 = a * b := by linarith
      have h₄ : gcd a b ∣ a := by apply Int.gcd_dvd_left
      have h₅ : gcd a b ∣ b := by apply Int.gcd_dvd_right
      have h₆ : gcd a b ∣ a * b := by
        apply dvd_mul_of_dvd_left h₄ b
      have h₇ : gcd a b ∣ a * b := by
        apply dvd_mul_of_dvd_right h₅ a
      have h₈ : gcd a b = a ∨ gcd a b = -a := by
        have h₉ : gcd a b ∣ a := by apply Int.gcd_dvd_left
        have h₁₀ : gcd a b ∣ b := by apply Int.gcd_dvd_right
        have h₁₁ : gcd a b ∣ a * b := by
          apply dvd_mul_of_dvd_left h₉ b
        have h₁₂ : gcd a b ∣ a * b := by
          apply dvd_mul_of_dvd_right h₁₀ a
        simp_all [Int.dvd_iff_emod_eq_zero, Int.mul_emod, Int.emod_emod]
        <;> omega
      cases h₈ with
      | inl h₈ =>
        have h₉ : a = b := by
          have h₁₀ : gcd a b = a := by assumption
          have h₁₁ : a ∣ b := by
            have h₁₂ : a ∣ gcd a b := by
              simp [h₁₀]
            have h₁₃ : gcd a b ∣ b := by apply Int.gcd_dvd_right
            exact dvd_trans h₁₂ h₁₃
          have h₁₄ : b ∣ a := by
            have h₁₅ : b ∣ gcd a b := by
              simp [h₁₀]
            have h₁₆ : gcd a b ∣ a := by apply Int.gcd_dvd_left
            exact dvd_trans h₁₅ h₁₆
          have h₁₇ : a = b := by
            apply Int.dvd_antisymm h₁₁ h₁₄
          exact h₁₇
        exact Or.inl h₉
      | inr h₈ =>
        have h₉ : a = -b := by
          have h₁₀ : gcd a b = -a := by assumption
          have h₁₁ : a ∣ b := by
            have h₁₂ : a ∣ gcd a b := by
              simp [h₁₀]
            have h₁₃ : gcd a b ∣ b := by apply Int.gcd_dvd_right
            exact dvd_trans h₁₂ h₁₃
          have h₁₄ : b ∣ a := by
            have h₁₅ : b ∣ gcd a b := by
              simp [h₁₀]
            have h₁₆ : gcd a b ∣ a := by apply Int.gcd_dvd_left
            exact dvd_trans h₁₅ h₁₆
          have h₁₇ : a = -b := by
            apply Int.eq_of_mul_eq_mul_right (show (2 : ℤ) ≠ 0 by norm_num)
            nlinarith
          exact h₁₇
        exact Or.inr h₉
    · intro h
      cases h with
      | inl h =>
        rw [h]
        simp [Int.gcd_eq_right, Int.lcm, Int.mul_comm]
        <;> ring_nf
        <;> simp_all
      | inr h =>
        rw [h]
        simp [Int.gcd_eq_right, Int.lcm, Int.mul_comm]
        <;> ring_nf
        <;> simp_all
  exact h₁
```

### Explanation

1. **Part (a):**
   - We first prove the forward direction: if `gcd(a, b) = lcm(a, b)`, then `a = b` or `a = -b`.
   - We use the property `gcd(a, b) * lcm(a, b) = a * b` and the fact that `gcd(a, b)` divides both `a` and `b`.
   - We then consider the possible values of `gcd(a, b)` and show that it must be either `a` or `-a`, leading to `a = b` or `a = -b`.
   - The reverse direction is straightforward by substituting `a = b` and `a = -b` into `gcd(a, b) = lcm(a, b)`.

2. **Part (b):**
   - We use the property `lcm(ka, kb) = |k| * lcm(a, b)`.
   - Since `k > 0`, `|k| = k`, so `lcm(ka, kb) = k * lcm(a, b)`.

3. **Part (c):**
   - Any common multiple `m` of `a` and `b` must be divisible by `lcm(a, b)`.
   - This is a fundamental property of the least common multiple.

### Normal Language Explanation

1. **Part (a):**
   - If `gcd(a, b) = lcm(a, b)`, then `a` and `b` must be equal or negatives of each other.
   - This is because `gcd(a, b)` divides both `a` and `b`, and `lcm(a, b)` is the smallest such number.
   - The only numbers where `gcd(a, b) = lcm(a, b)` are those where `a` and `b` are equal or negatives of each other.

2. **Part (b):**
   - Multiplying both `a` and `b` by `k` scales the `lcm` by `k`.
   - This is because `lcm` is the smallest number divisible by both `ka` and `kb`, and it scales with `k`.

3. **Part (c):**
   - Any common multiple `m` of `a` and `b` must be divisible by `lcm(a, b)`.
   - This is because `lcm(a, b)` is the smallest such number, so any other common multiple must be a multiple of it.