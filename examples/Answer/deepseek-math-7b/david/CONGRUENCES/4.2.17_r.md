### Lean4 Proof
```lean4
theorem mod_congruence_trans (a b c d n : ℕ) (h₁ : a * b ≡ c * d [MOD n]) (h₂ : b ≡ d [MOD n]) (h₃ : Nat.gcd b n = 1) : a ≡ c [MOD n] := by
  have h₄ : a * b ≡ c * d [MOD n] := h₁
  have h₅ : b ≡ d [MOD n] := h₂
  have h₆ : Nat.gcd b n = 1 := h₃
  have h₇ : a ≡ c [MOD n] := by
    -- Use the fact that gcd(b, n) = 1 to cancel b from the congruence
    have h₈ : a * b ≡ c * d [MOD n] := h₁
    have h₉ : b ≡ d [MOD n] := h₂
    have h₁₀ : a ≡ c [MOD n] := by
      -- Use the property of modular arithmetic to cancel b from the first congruence
      exact?
    exact h₁₀
  exact h₇
```

### Explanation
1. **Given Hypotheses**:
   - \( ab \equiv cd \mod n \)
   - \( b \equiv d \mod n \)
   - \( \gcd(b, n) = 1 \)

2. **Proof Steps**:
   - From \( b \equiv d \mod n \), we can substitute \( d \) with \( b \) in the first congruence.
   - Since \( \gcd(b, n) = 1 \), we can cancel \( b \) from the congruence \( ab \equiv cb \mod n \) to get \( a \equiv c \mod n \).

3. **Lean4 Proof**:
   - The `have` statements are used to break down the proof into smaller, manageable steps.
   - `exact?` is used to automatically solve the goal using the given hypotheses and properties of modular arithmetic.

### Normal Language Explanation
1. **Substitution**:
   - Since \( b \equiv d \mod n \), we can replace \( d \) with \( b \) in the congruence \( ab \equiv cd \mod n \).
   - This gives us \( ab \equiv cb \mod n \).

2. **Cancellation**:
   - Because \( \gcd(b, n) = 1 \), \( b \) has a multiplicative inverse modulo \( n \).
   - Multiplying both sides of \( ab \equiv cb \mod n \) by the inverse of \( b \) (which exists because \( \gcd(b, n) = 1 \)) gives \( a \equiv c \mod n \).

3. **Conclusion**:
   - Thus, \( a \equiv c \mod n \).