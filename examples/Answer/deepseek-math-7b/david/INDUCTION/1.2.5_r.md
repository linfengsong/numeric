### Part (a): Proving the Binomial Identity

**Lean4 Proof Sketch:**

```lean4
theorem part_a (n : ℕ) (hn : n ≥ 2) : 
    ∑ k in Finset.Icc 2 n, Nat.choose k 2 = Nat.choose (n + 1) 3 := by
  have h : ∀ n : ℕ, n ≥ 2 → ∑ k in Finset.Icc 2 n, Nat.choose k 2 = Nat.choose (n + 1) 3 := by
    intro n hn
    induction' hn with n hn
    · -- Base case: n = 2
      simp [Finset.sum_Icc_succ_top, Nat.choose_two_right]
    · -- Inductive step: assume true for n, prove for n + 1
      cases n with
      | zero => contradiction -- n cannot be zero since hn : n ≥ 2
      | succ n =>
        cases n with
        | zero => contradiction -- n cannot be one since hn : n ≥ 2
        | succ n =>
          simp_all [Finset.sum_Icc_succ_top, Nat.choose_succ_succ, add_comm, add_left_comm, add_assoc]
          <;> ring_nf at *
          <;> omega
  exact h n hn
```

**Explanation:**
1. We use induction on `n` with the base case `n = 2` and the inductive step assuming the statement holds for `n` and proving it for `n + 1`.
2. The base case `n = 2` is verified by direct computation.
3. For the inductive step, we use the induction hypothesis and simplify the sum using properties of binomial coefficients and the Pascal's identity.
4. The `ring_nf` and `omega` tactics are used to simplify and solve the resulting equations.

### Part (b): Deducing the Sum of Squares Formula

**Lean4 Proof Sketch:**

```lean4
theorem part_b (n : ℕ) (hn : n ≥ 2) : 
    ∑ k in Finset.Icc 1 n, k^2 = n * (n + 1) * (2 * n + 1) / 6 := by
  have h : ∀ n : ℕ, n ≥ 2 → ∑ k in Finset.Icc 1 n, k^2 = n * (n + 1) * (2 * n + 1) / 6 := by
    intro n hn
    induction' hn with n hn
    · -- Base case: n = 2
      simp [Finset.sum_Icc_succ_top]
    · -- Inductive step: assume true for n, prove for n + 1
      cases n with
      | zero => contradiction -- n cannot be zero since hn : n ≥ 2
      | succ n =>
        cases n with
        | zero => contradiction -- n cannot be one since hn : n ≥ 2
        | succ n =>
          simp_all [Finset.sum_Icc_succ_top, Nat.succ_eq_add_one, Nat.mul_div_cancel_left]
          <;> ring_nf at *
          <;> omega
  exact h n hn
```

**Explanation:**
1. We use induction on `n` with the base case `n = 2` and the inductive step assuming the statement holds for `n` and proving it for `n + 1`.
2. The base case `n = 2` is verified by direct computation.
3. For the inductive step, we use the induction hypothesis and simplify the sum using properties of sums and algebraic manipulations.
4. The `ring_nf` and `omega` tactics are used to simplify and solve the resulting equations.

### Part (c): Proving the Sum of Products Formula

**Lean4 Proof Sketch:**

```lean4
theorem part_c (n : ℕ) (hn : n ≥ 2) : 
    ∑ k in Finset.Icc 1 n, k * (k + 1) = n * (n + 1) * (n + 2) / 3 := by
  have h : ∀ n : ℕ, n ≥ 2 → ∑ k in Finset.Icc 1 n, k * (k + 1) = n * (n + 1) * (n + 2) / 3 := by
    intro n hn
    induction' hn with n hn
    · -- Base case: n = 2
      simp [Finset.sum_Icc_succ_top]
    · -- Inductive step: assume true for n, prove for n + 1
      cases n with
      | zero => contradiction -- n cannot be zero since hn : n ≥ 2
      | succ n =>
        cases n with
        | zero => contradiction -- n cannot be one since hn : n ≥ 2
        | succ n =>
          simp_all [Finset.sum_Icc_succ_top, Nat.succ_eq_add_one, Nat.mul_div_cancel_left]
          <;> ring_nf at *
          <;> omega
  exact h n hn
```

**Explanation:**
1. We use induction on `n` with the base case `n = 2` and the inductive step assuming the statement holds for `n` and proving it for `n + 1`.
2. The base case `n = 2` is verified by direct computation.
3. For the inductive step, we use the induction hypothesis and simplify the sum using properties of sums and algebraic manipulations.
4. The `ring_nf` and `omega` tactics are used to simplify and solve the resulting equations.

### Final Answer

The Lean4 proofs for each part are provided above. The key steps involve induction, base case verification, and algebraic manipulation to match the given identities. The `ring_nf` and `omega` tactics are used to simplify and solve the resulting equations.